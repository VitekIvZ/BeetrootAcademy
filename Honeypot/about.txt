У кібербезпеці горщик з медом - це система приманок, яка призначена для залучення, а потім виявлення потенційних зловмисників, які намагаються скомпрометувати систему. Так само, як горщик з медом, що стоїть на відкритому повітрі, приваблює мух.
Уявіть собі, що ці горщики з медом - це камери спостереження для вашої системи. Подібно до того, як камера спостереження допомагає нам зрозуміти, хто намагається проникнути в будівлю і як вони це роблять, так і медовий горщик допоможе вам зрозуміти, хто намагається атакувати вашу систему і які методи вони використовують.

Розуміння типів медоносних горщиків
Перш ніж ми почнемо розробляти власний горщик для меду, давайте швидко розберемося в їхніх різних типах:
1. Виробничі вулики: Ці типи горщиків розміщуються в реальному виробничому середовищі і використовуються для виявлення реальних атак на безпеку. Вони, як правило, прості за конструкцією, легкі в обслуговуванні та розгортанні і пропонують обмежену взаємодію для зменшення ризиків.
2. Дослідницькі горщики: Це більш складні системи, створені дослідниками безпеки для вивчення шаблонів атак, проведення емпіричного аналізу цих шаблонів, збору зразків шкідливого програмного забезпечення та розуміння нових методів атак, які не були виявлені раніше. Вони часто емулюють цілі операційні системи або мережі, а не поводяться як програми у виробничому середовищі.

Як налаштувати середовище розробки
Почнемо з налаштування середовища розробки на Python. Запустіть наступні команди:
Ми будемо використовувати вбудовані бібліотеки, тому нам не потрібно буде встановлювати жодних зовнішніх залежностей. Ми будемо зберігати наші логи у каталозі honeypot_logs.

Як побудувати основний "медовий горщик
Наш базовий медовий горщик складатиметься з трьох компонентів:
1. Мережевий слухач, який приймає з'єднання
2. Система реєстрації для фіксації діяльності
3. Базовий сервіс емуляції для взаємодії зі зловмисниками

Почнемо з ініціалізації базового класу Honeypot:

Цей клас містить багато важливої інформації, тому давайте розглянемо кожну функцію по черзі.
Функція __init__ записує IP-адресу та номери портів, на яких ми розмістимо honeypot, а також шлях / ім'я файлу журналу. Ми також будемо вести облік загальної кількості активних підключень до honeypot.
Функція log_activity отримає інформацію про IP-адресу, дані та порт, до якого IP-адреса намагалася з'єднатися. Потім ми додамо цю інформацію до нашого лог-файлу у форматі JSON.
Функція handle_connection імітуватиме ці сервіси, які працюватимуть на різних портах. У нас буде запущено honeypot на портах 21, 22, 80 і 443. Ці порти призначені для FTP, SSH, HTTP і протоколу HTTPS відповідно. Тому будь-який зловмисник, який намагається взаємодіяти з honeypot, повинен очікувати ці сервіси на цих портах.
Щоб імітувати поведінку цих сервісів, ми будемо використовувати сервісні банери, які вони використовують в реальності. Ця функція спочатку надсилатиме відповідний банер при підключенні зловмисника, а потім отримуватиме дані і записуватиме їх у журнал. Honeypot також надішле зловмиснику фальшиву відповідь "Команда не розпізнана".

Впровадження мережевих слухачів
Тепер реалізуємо мережеві слухачі, які будуть обробляти вхідні з'єднання. Для цього ми будемо використовувати просте програмування сокетів. Якщо ви не знаєте, як працює програмування сокетів, ознайомтеся з цією статтею, яка пояснює деякі поняття, пов'язані з ним.
Функція start_listener запустить сервер і буде слухати на вказаному порту. Параметр bind_ip у нас буде 0.0.0.0, що вказує на те, що сервер буде слухати на всіх мережевих інтерфейсах.
Тепер ми будемо обробляти кожне нове з'єднання в окремому потоці, оскільки можуть бути випадки, коли кілька зловмисників намагаються взаємодіяти з honeypot або зловмисний скрипт або інструмент сканує honeypot. Якщо ви не знаєте, як працює багатопотоковість, ви можете ознайомитися з цією статтею, яка пояснює багатопотоковість і паралелізм в Python.
Також не забудьте помістити цю функцію в основний клас Honeypot.

Запустити медовий горщик
Тепер давайте створимо головну функцію, яка запустить наш медовий горщик.
Ця функція створює екземпляр класу Honeypot і запускає слухачі для кожного з визначених нами портів (21,22,80,443) як окремий потік. Тепер ми збережемо наш основний потік, який виконує нашу програму, живим, помістивши його в нескінченний цикл. Об'єднайте все це у скрипт і запустіть його.

Напишіть симулятор атаки Honeypot
Тепер давайте спробуємо змоделювати кілька сценаріїв атаки і націлимося на наш медовий горщик, щоб зібрати деякі дані в нашому JSON-файлі журналу.
Цей симулятор допоможе нам продемонструвати кілька важливих аспектів, пов'язаних з медовими горщиками:
1. Реалістичні моделі атак: Симулятор імітує поширені моделі атак, такі як сканування портів, спроби грубої сили та експлойти для конкретних сервісів.
2. Змінна інтенсивність: Тренажер регулює інтенсивність симуляції, щоб перевірити, як ваш медовий горщик справляється з різними навантаженнями.
3. Кілька типів атак: Він продемонструє різні типи атак, до яких можуть вдатися реальні зловмисники, і допоможе вам зрозуміти, як ваш медовий горщик реагує на кожну з них.
4. Одночасні з'єднання: Симулятор використовує потокове з'єднання, щоб перевірити, як ваш медовий горщик справляється з декількома одночасними з'єднаннями.
У цьому симуляційному скрипті багато чого відбувається, тому давайте розберемо його по пунктах. Я також додав коментарі до кожної функції та операції, щоб зробити код більш читабельним.
Спочатку ми створимо наш утилітарний клас під назвою HoneypotSimulator. У цьому класі ми маємо функцію __init__, яка встановлює базову конфігурацію для нашого симулятора. Вона приймає два параметри: цільову IP-адресу (за замовчуванням localhost) та рівень інтенсивності (за замовчуванням "medium").
Ми також визначаємо три важливі компоненти: цільові порти для дослідження (загальні сервіси, такі як FTP, SSH, HTTP), шаблони атак, специфічні для кожного сервісу (наприклад, спроби входу та команди), та налаштування інтенсивності, які контролюють, наскільки агресивною буде наша симуляція за допомогою кількості потоків та часових затримок.
Функція simulate_connection обробляє окремі спроби підключення до певного порту. Вона створює з'єднання з сокетом, намагається отримати будь-які сервісні банери (наприклад, інформацію про версію SSH), а потім надсилає відповідні команди атаки на основі типу сервісу. Ми додали обробку помилок для вирішення поширених мережевих проблем, а також реалістичні затримки між командами, щоб імітувати людську взаємодію.
Наша функція simulate_port_scan діє як розвідувальний інструмент, який систематично перевіряє кожен порт у нашому цільовому списку. Це схоже на те, як працюють такі інструменти, як nmap - перебираючи порти один за одним, щоб побачити, які сервіси доступні. Для кожного порту він викликає функцію simulate_connection і додає невеликі випадкові затримки, щоб шаблон сканування виглядав більш природно.
Функція simulate_brute_force зберігає списки поширених імен користувачів і паролів, намагаючись підібрати різні комбінації до таких сервісів, як FTP і SSH. Для кожної спроби вона створює нове з'єднання, надсилає облікові дані для входу в правильному форматі для цього сервісу, а потім закриває з'єднання. Це допомагає нам перевірити, наскільки добре honeypot виявляє та реєструє атаки з підміною облікових даних.
Функція run_continuous_simulation працює протягом заданого часу, випадковим чином вибираючи між різними типами атак, такими як сканування портів, груба сила або атаки на певні сервіси. Вона використовує ThreadPoolExecutor Python для одночасного запуску декількох атак на основі заданого рівня інтенсивності.
Нарешті, ми маємо основну функцію, яка забезпечує інтерфейс командного рядка для симулятора. Вона використовує argparse для обробки аргументів командного рядка, дозволяючи користувачам вказувати цільову IP-адресу, рівень інтенсивності та тривалість симуляції. Він створює екземпляр класу HoneypotSimulator і керує загальним виконанням, включаючи належну обробку переривань і помилок користувача.
Винісши код симулятора в окремий скрипт, запустіть його наступною командою:
# Run with default settings (medium intensity, localhost, 5 minutes)
python honeypot_simulator.py

# Run with custom settings
python honeypot_simulator.py --target 192.168.1.100 --intensity high --duration 600
Оскільки ми запускаємо honeypot і симулятор на одному комп'ютері локально, метою буде localhost. Але в реальному сценарії це може бути щось інше, або якщо ви запускаєте honeypot у віртуальній машині чи на іншому комп'ютері - тому переконайтеся, що ви підтвердили IP, перш ніж запускати симулятор.

Як аналізувати дані Honeypot
Давайте швидко напишемо допоміжну функцію, яка дозволить нам проаналізувати всі дані, зібрані Honeypot. Оскільки ми зберегли їх у файлі логу в форматі JSON, ми можемо зручно проаналізувати їх за допомогою вбудованого пакету JSON.
Ви можете розмістити його в окремому файлі скрипта і викликати функцію на JSON журналах. Ця функція надасть нам вичерпну інформацію з JSON-файлу на основі зібраних даних.
Наш аналіз починається з групування даних за кількома категоріями, такими як статистика на основі IP-адрес, шаблони націлювання на порти, погодинний розподіл атак і характеристики корисного навантаження. Для кожної IP-адреси ми відстежуємо загальну кількість спроб, час першого та останнього відвідування, цільові порти та унікальне корисне навантаження. Це допоможе нам створити унікальні профілі зловмисників.
Ми також досліджуємо шаблони атак на основі портів, які відстежують порти, що найчастіше стають об'єктами атак, і кількість унікальних зловмисників. Ми також проводимо аналіз складності атак, який допомагає нам ідентифікувати зловмисників, беручи до уваги такі фактори, як порти, що атакуються, та унікальне корисне навантаження, що використовується. Цей аналіз використовується для відокремлення простого сканування від складних атак.
Часовий аналіз допомагає нам виявляти закономірності в погодинних спробах атак, що дозволяє виявити закономірності в часі атак і потенційні автоматизовані кампанії таргетингу. Нарешті, ми публікуємо найпоширеніші корисні навантаження, щоб виявити найпоширеніші рядки або команди атак.

Міркування безпеки
Під час розгортання цього медового горщика обов'язково врахуйте наступні заходи безпеки:
1. Запустіть свій honeypot в ізольованому середовищі. Зазвичай у віртуальній машині або на локальному комп'ютері, який знаходиться за NAT і брандмауером.
2. Запустіть honeypot з мінімальними системними привілеями (зазвичай не від імені користувача root), щоб зменшити ризик компрометації.
3. Будьте обережні зі зібраними даними, якщо ви плануєте використовувати їх у виробничих або дослідницьких цілях, оскільки вони можуть містити шкідливе програмне забезпечення або конфіденційну інформацію.
4. Впровадити надійні механізми моніторингу для виявлення спроб вирватися за межі "медового горщика".

Висновок
Для цього ми побудували наш "медовий горщик", написали симулятор для імітації атак на наш "медовий горщик" і проаналізували дані з логів нашого "медового горщика", щоб зробити кілька простих висновків. Це чудовий спосіб зрозуміти як наступальні, так і захисні концепції безпеки. Ви можете використовувати його для створення більш складних систем виявлення і подумати про додавання таких функцій, як:
1. Динамічна емуляція сервісів на основі поведінки атак
2. Інтеграція з системами розвідки загроз, які дозволять виконувати кращий аналіз висновків з цих зібраних журналів
3. Збирайте вичерпні журнали, окрім даних про IP-адресу, порт і мережу, за допомогою розширених механізмів ведення журналів
4. Додайте можливості машинного навчання для виявлення шаблонів атак

Пам'ятайте, що хоча вулики є потужним інструментом захисту, вони повинні бути частиною комплексної оборонної стратегії безпеки, а не єдиною лінією захисту.
Сподіваюся, ви дізналися про те, як працюють вулики, для чого вони призначені, а також навчилися трохи програмувати на Python!




